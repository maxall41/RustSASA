use nalgebra::{Point3, Vector3};
use rstar::{RTree, RTreeObject, AABB};
use rayon::prelude::*;
use std::sync::Arc;

// Adjust the Atom struct to implement the necessary traits for RTreeObject
#[derive(Debug, Clone)]
struct Atom {
    position: Point3<f32>,
    radius: f32,
}

impl RTreeObject for Atom {
    type Envelope = AABB<[f32; 3]>;

    fn envelope(&self) -> Self::Envelope {
        AABB::from_point([self.position.x, self.position.y, self.position.z])
            .expand(self.radius) // Consider the atom's radius in its bounding box
    }
}

// Function to check atom accessibility considering the use of R-star tree for spatial lookup
fn is_accessible_rstar(test_point: &Point3<f32>, atom: &Atom, tree: &RTree<Atom>, probe_radius: f32) -> bool {
    let search_envelope = AABB::from_point([test_point.x, test_point.y, test_point.z])
        .expand(probe_radius);

    // Retrieve potential intersecting atoms using the spatial index
    let candidates = tree.locate_in_envelope(&search_envelope);

    for other_atom in candidates {
        if !std::ptr::eq(atom, other_atom) && (test_point - other_atom.position).norm() < (other_atom.radius + probe_radius) {
            return false;
        }
    }
    true
}

// Adjusted main ASA calculation to use R*-tree for spatial queries
fn calculate_asa(atoms: &[Atom], probe_radius: f32, n_points: usize) -> Vec<f32> {
    let sphere_points = generate_sphere_points(n_points);

    // Create R*-tree from atoms for efficient spatial lookup
    let tree = RTree::bulk_load(atoms.to_vec());
    let tree_arc = Arc::new(tree); // Use Arc for safe sharing among threads

    atoms.par_iter().map(|atom| {
        let mut accessible_points = 0;

        for sphere_point in &sphere_points {
            let test_point = atom.position + sphere_point * (atom.radius + probe_radius);

            // Pass the shared R*-tree to the accessibility checker
            if is_accessible_rstar(&test_point, atom, &tree_arc, probe_radius) {
                accessible_points += 1;
            }
        }

        4.0 * std::f32::consts::PI * (atom.radius + probe_radius).powi(2) * (accessible_points as f32) / (n_points as f32)
    }).collect()
}

// Remaining implementation (e.g., `generate_sphere_points`, `main` function) stays the same
This version of the code leverages the rstar library to enhance the performance of spatial lookups with an R*-tree. By efficiently querying the tree for potentially intersecting atoms, the code can significantly reduce the number of distance checks needed to determine if a point is accessible.

This adjustment is crucial for datasets with a large number of atoms, where the naively implemented distance checks would otherwise result in a substantial computational bottleneck. The use of Arc (atomic reference counting) allows for safe and efficient sharing of the R*-tree across multiple threads, fitting perfectly with the parallel processing approach facilitated by rayon.